<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowCraft • Data Matrix</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/sidebar.css">
    <link rel="stylesheet" href="/static/css/index.css">
    <link rel="stylesheet" href="/static/css/data_matrix.css">
</head>
<body>
    <div class="app_container">
    {% include 'partials/sidebar.html' %}
        <div class="main_content full_width" style="display:flex; flex-direction:column;">
            <div class="data_matrix_container" style="flex:1;">
                <div id="dm_content" class="dm_content">
                    <!-- one block per execution -->
                </div>
            </div>
        {% include 'partials/status_bar.html' %}
        <style>
            /* hide node count on data matrix page */
            #node_count { display: none; }
            /* hide coordinates on data matrix page */
            #node_coordinates { display: none !important; }
        </style>
        </div>
    </div>

    <!-- create flowchart modal (data matrix page) -->
    <div class="modal_overlay" id="create_flowchart_modal">
        <div class="modal_content">
            <div class="modal_header">
                <h2 class="modal_title">CREATE NEW FLOWCHART</h2>
                <button class="modal_close" id="close_create_modal">
                    <span class="material-icons">close</span>
                </button>
            </div>
            <div class="form_group">
                <label class="form_label" for="new_flowchart_name">flowchart name</label>
                <input type="text" id="new_flowchart_name" class="form_input" placeholder="enter flowchart name..." maxlength="50">
                <div style="font-size: 0.75rem; color: var(--on-surface); opacity: 0.7; margin-top: 4px;">use letters, numbers, hyphens, and underscores only (no spaces)</div>
            </div>
            <div class="modal_actions">
                <button class="btn_modal btn_modal_secondary" id="cancel_create_flowchart">CANCEL</button>
                <button class="btn_modal btn_modal_primary" id="confirm_create_flowchart">CREATE</button>
            </div>
        </div>
    </div>

    <script>
    (async function(){
        // small helpers (keep comments in lower case to match project convention)
        const $ = (sel) => document.querySelector(sel);
        const container = document.getElementById('dm_content');
        function el(tag, cls, html){ const e = document.createElement(tag); if(cls) e.className = cls; if(html!==undefined) e.innerHTML = html; return e; }
        
        // format timestamp for better readability
        function formatTimestamp(timestamp) {
            if (!timestamp || timestamp === '-') return '-';
            try {
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) return timestamp; // fallback to original if invalid
                
                const now = new Date();
                const diffMs = now - date;
                const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                const diffMinutes = Math.floor(diffMs / (1000 * 60));
                
                // format date
                const options = { 
                    month: 'short', 
                    day: 'numeric', 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: true
                };
                const formattedDate = date.toLocaleDateString('en-US', options);
                
                // add relative time for recent executions
                if (diffMinutes < 1) {
                    return `${formattedDate} (just now)`;
                } else if (diffMinutes < 60) {
                    return `${formattedDate} (${diffMinutes}m ago)`;
                } else if (diffHours < 24) {
                    return `${formattedDate} (${diffHours}h ago)`;
                } else if (diffDays < 7) {
                    return `${formattedDate} (${diffDays}d ago)`;
                } else {
                    return formattedDate;
                }
            } catch (e) {
                return timestamp; // fallback to original
            }
        }

        // diagnostics
        try { console.log('[dm] init data matrix page'); } catch(_) {}
        if (!container) { try { console.warn('[dm] container #dm_content not found'); } catch(_) {} }
        try {
            console.log('[dm] document.readyState', document.readyState);
            if (container) {
                const cs = window.getComputedStyle(container);
                const rect = container.getBoundingClientRect();
                console.log('[dm] container style', { display: cs.display, visibility: cs.visibility, position: cs.position });
                console.log('[dm] container rect', { x: rect.x, y: rect.y, w: rect.width, h: rect.height });
            }
        } catch(_) {}

        // unify flowchart context from url
        const params = new URLSearchParams(window.location.search);
        const modeParam = params.get('mode') || 'build';
        const flowNameParam = params.get('flowchart'); // display form (no .json)
        const flowFileParam = params.get('flowchart_name'); // filename form (with .json)
        const flowDisplay = (flowNameParam || (flowFileParam ? flowFileParam.replace(/\.json$/i, '') : 'default'));
        const flowFilename = (flowFileParam || `${flowDisplay}.json`);
        try { console.log('[dm] url params', { modeParam, flowNameParam, flowFileParam, flowDisplay, flowFilename }); } catch(_) {}

        // wire sidebar navigation to preserve flowchart across pages
        function withFlowchart(href){
            const u = new URL(href, window.location.origin);
            // builder pages + dashboard use ?flowchart=display and ?mode=...
            if (u.pathname === '/' || u.pathname === '/scripts' || u.pathname === '/dashboard') {
                if (flowDisplay && flowDisplay !== 'default') u.searchParams.set('flowchart', flowDisplay); else u.searchParams.delete('flowchart');
                if (!u.searchParams.get('mode')) u.searchParams.set('mode', modeParam || 'build');
            }
            // data matrix uses ?flowchart_name=filename
            if (u.pathname === '/data') {
                u.searchParams.set('flowchart_name', flowFilename || 'default.json');
            }
            return u.pathname + (u.search ? u.search : '');
        }

        const navMap = new Map([
            ['dashboard_btn','/dashboard'],
            ['build_btn','/?mode=build'],
            ['scripts_btn','/scripts'],
            ['run_btn','/?mode=run'],
            ['export_btn','/'],
            ['settings_btn','/?mode=settings'],
            ['data_matrix_btn','/data']
        ]);
        navMap.forEach((href, id) => {
            const elx = document.getElementById(id);
            if (elx) {
                elx.onclick = () => {
                    try { console.log('[dm] nav click', id, href); } catch(_) {}
                    window.location.href = withFlowchart(href);
                };
            }
        });

        // highlight data matrix as active; clear others
        (['build_btn','scripts_btn','run_btn','settings_btn','export_btn','data_matrix_btn']).forEach(id => {
            const el = document.getElementById(id); if (el) { el.classList.remove('active'); el.classList.remove('run_mode_active'); }
        });
        const dmBtn = document.getElementById('data_matrix_btn'); if (dmBtn) dmBtn.classList.add('active');

        // back link should preserve flowchart context to builder
        // no back link on data matrix

        // flowchart dropdown: fetch and populate, keep selection reflecting current flow
        const selector = document.getElementById('flowchart_selector');
        const dropdown = document.getElementById('flowchart_dropdown');
        const createBtn = document.getElementById('create_flowchart_btn');
        const createModal = document.getElementById('create_flowchart_modal');
        const closeCreateModal = document.getElementById('close_create_modal');
        const cancelCreate = document.getElementById('cancel_create_flowchart');
        const confirmCreate = document.getElementById('confirm_create_flowchart');
        const newFlowchartNameInput = document.getElementById('new_flowchart_name');

        async function fetchFlowcharts(){
            try {
                const resp = await fetch('/api/flowcharts');
                const data = await resp.json();
                try { console.log('[dm] /api/flowcharts resp', { ok: resp.ok, status: resp.status, count: (data.flowcharts||[]).length, data }); } catch(_) {}
                if (data.status === 'success') {
                    renderDropdown(data.flowcharts || []);
                    if (selector) selector.value = flowDisplay || 'default';
                } else {
                    dropdown.innerHTML = '<div class="dropdown_no_results">failed to load flowcharts</div>';
                }
            } catch (_) {
                try { console.error('[dm] /api/flowcharts error', _); } catch(e) {}
                dropdown.innerHTML = '<div class="dropdown_no_results">error loading flowcharts</div>';
            }
        }

        function renderDropdown(items){
            if (!items.length) { dropdown.innerHTML = '<div class="dropdown_no_results">no flowcharts found</div>'; return; }
            dropdown.innerHTML = items.map(f => `
                <div class="dropdown_item" data-filename="${f.filename}" data-name="${f.name}">
                    <div class="dropdown_item_content">
                        <div class="dropdown_item_name">${f.name}</div>
                    </div>
                    <button class="dropdown_delete_btn" data-filename="${f.filename}" data-name="${f.name}" title="delete flowchart">
                        <span class="material-icons">delete</span>
                    </button>
                </div>
            `).join('');
            dropdown.querySelectorAll('.dropdown_item').forEach(item => {
                item.addEventListener('click', (ev) => {
                    if (ev && ev.target && ev.target.closest && ev.target.closest('.dropdown_delete_btn')) return;
                    if (selector) selector.value = item.dataset.name;
                    toggleDropdown(false);
                    // stay on data matrix; update flowchart_name
                    const url = new URL('/data', window.location.origin);
                    url.searchParams.set('flowchart_name', item.dataset.filename);
                    // preserve mode for consistency in nav
                    url.searchParams.set('mode', modeParam || 'build');
                    try { localStorage.setItem('last_accessed_flowchart', item.dataset.filename); } catch(_) {}
                    window.location.href = url.pathname + '?' + url.searchParams.toString();
                });
            });

            dropdown.querySelectorAll('.dropdown_delete_btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const filename = btn.dataset.filename;
                    const name = btn.dataset.name;
                    if (!confirm(`are you sure you want to delete the flowchart "${name}"? this action cannot be undone.`)) return;
                    try {
                        const resp = await fetch(`/api/flowcharts/${encodeURIComponent(filename)}`, { method: 'DELETE' });
                        const json = await resp.json();
                        if (!resp.ok) { alert(json.message || 'error deleting flowchart'); return; }
                        // refresh list
                        const listResp = await fetch('/api/flowcharts');
                        const listJson = await listResp.json();
                        const flows = (listJson && Array.isArray(listJson.flowcharts)) ? listJson.flowcharts : [];
                        renderDropdown(flows);
                        // if current selection was deleted, pick newest and reload page with its flowchart_name
                        if (filename === flowFilename) {
                            if (flows.length > 0) {
                                const fallback = flows[0];
                                if (selector) selector.value = fallback.name;
                                const url = new URL('/data', window.location.origin);
                                url.searchParams.set('flowchart_name', fallback.filename);
                                url.searchParams.set('mode', modeParam || 'build');
                                try { localStorage.setItem('last_accessed_flowchart', fallback.filename); } catch(_) {}
                                window.location.href = url.pathname + '?' + url.searchParams.toString();
                            } else {
                                // nothing left: clear selection and reload
                                const url = new URL('/data', window.location.origin);
                                url.searchParams.delete('flowchart_name');
                                url.searchParams.set('mode', modeParam || 'build');
                                try { localStorage.removeItem('last_accessed_flowchart'); } catch(_) {}
                                window.location.href = url.pathname + (url.search ? url.search : '');
                            }
                        }
                    } catch(_) {
                        alert('error deleting flowchart');
                    }
                });
            });
        }

        function toggleDropdown(force){ const show = typeof force === 'boolean' ? force : !dropdown.classList.contains('show'); dropdown.classList.toggle('show', show); }
        if (selector) {
            selector.addEventListener('click', (e) => { e.stopPropagation(); toggleDropdown(); });
            document.addEventListener('click', (e) => { const container = selector.closest('.dropdown_container'); if (container && !container.contains(e.target)) dropdown.classList.remove('show'); });
            fetchFlowcharts();
        }

        // create flowchart from data matrix: open local modal, do not navigate
        if (createBtn) {
            createBtn.onclick = (e) => {
                e.preventDefault();
                if (createModal) createModal.classList.add('show');
                if (newFlowchartNameInput) { newFlowchartNameInput.value = ''; newFlowchartNameInput.focus(); }
            };
        }
        if (closeCreateModal) closeCreateModal.onclick = () => { if (createModal) createModal.classList.remove('show'); };
        if (cancelCreate) cancelCreate.onclick = () => { if (createModal) createModal.classList.remove('show'); };
        if (createModal) createModal.addEventListener('click', (e) => { if (e.target === createModal) createModal.classList.remove('show'); });
            if (confirmCreate) {
            confirmCreate.onclick = async () => {
                const rawName = (newFlowchartNameInput && newFlowchartNameInput.value ? newFlowchartNameInput.value : '').trim();
                if (!rawName) { alert('flowchart name is required'); return; }
                try {
                    const resp = await fetch('/api/flowcharts', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name: rawName })});
                    const data = await resp.json();
                    if (data.status === 'success') {
                        if (createModal) createModal.classList.remove('show');
                        await fetchFlowcharts();
                        if (selector) selector.value = data.flowchart.name;
                        // update url to reflect new selection on data page
                        const u = new URL(window.location.href);
                        u.searchParams.set('flowchart_name', data.flowchart.filename);
                            try { localStorage.setItem('last_accessed_flowchart', data.flowchart.filename); } catch(_) {}
                        window.history.replaceState(null, '', u.pathname + '?' + u.searchParams.toString());
                    } else {
                        alert(data.message || 'failed to create flowchart');
                    }
                } catch(_) { alert('error creating flowchart'); }
            };
            if (newFlowchartNameInput) { 
                newFlowchartNameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') confirmCreate.click(); });
                // prevent spaces from being entered
                newFlowchartNameInput.addEventListener('keypress', (e) => {
                    if (e.key === ' ') {
                        e.preventDefault();
                    }
                });
                // also prevent paste of content with spaces
                newFlowchartNameInput.addEventListener('paste', (e) => {
                    const pastedText = (e.clipboardData || window.clipboardData).getData('text');
                    if (pastedText.includes(' ')) {
                        e.preventDefault();
                    }
                });
            }
        }

        // fetch latest history for current flowchart
        try { console.log('[dm] fetching history for', flowFilename); } catch(_) {}
        let data;
        try {
        const res = await fetch(`/api/history?flowchart_name=${encodeURIComponent(flowFilename)}`);
            try { console.log('[dm] /api/history status', res.status); } catch(_) {}
            data = await res.json();
            try { console.log('[dm] /api/history json', data); } catch(_) {}
        } catch (err) {
            try { console.error('[dm] /api/history fetch failed', err); } catch(_) {}
            container.appendChild(el('div','dm_error','failed to load history (network error)'));
            return;
        }
        if (!data || data.status !== 'success') {
            try { console.warn('[dm] history api returned non-success', data); } catch(_) {}
            container.appendChild(el('div','dm_error','failed to load history'));
            return;
        }

        const executions = data.history || [];
        try { console.log('[dm] executions count', executions.length); } catch(_) {}
        if (executions.length === 0) {
            try { console.log('[dm] no executions for', flowFilename); } catch(_) {}
            container.appendChild(el('div','dm_empty','no executions yet'));
            return;
        }

        // helper to fetch full execution details for richer data
        async function fetchDetails(executionId){
            try { console.log('[dm] fetching details for', executionId); } catch(_) {}
            try {
                const resp = await fetch(`/api/history/${executionId}?flowchart_name=${encodeURIComponent(flowFilename)}`);
                const json = await resp.json();
                try { console.log('[dm] details status', resp.status, 'id', executionId); } catch(_) {}
                if (json && json.status === 'success') return json.execution;
                try { console.warn('[dm] details non-success', json); } catch(_) {}
            } catch (e) {
                try { console.error('[dm] details fetch error', e); } catch(_) {}
            }
            return null;
        }

        // render one row block per execution and enrich with detailed data
        const detailPromises = executions.map(exec => fetchDetails(exec.execution_id));
        const details = await Promise.all(detailPromises);
        try { console.log('[dm] fetched details count', details.length); } catch(_) {}
        executions.forEach((exec, idx) => {
            try { console.log('[dm] render row', { idx, exec, detail: details[idx] }); } catch(_) {}
            const row = el('div','dm_row');

            // left: high-level execution info
            const left = el('div','dm_left');
            const statusBadge = exec.status === 'success' ? 'success' : (exec.status === 'failed' ? 'failed' : 'info');
            // header row: status on left, actions on right (within left panel)
            const headerRow = el('div','dm_left_header');
            const statusEl = el('div',`dm_status dm_status_${statusBadge}`, exec.status || 'unknown');
            headerRow.appendChild(statusEl);

            // row actions (view/delete)
            const actions = el('div','dm_actions_row');
            const viewBtn = el('button','btn btn_secondary dm_row_btn','<span class="material-icons">visibility</span><span class="btn_label">View</span>');
            const delBtn = el('button','btn btn_secondary btn_danger_subtle dm_row_btn','<span class="material-icons">delete</span><span class="btn_label">Delete</span>');
            actions.appendChild(viewBtn);
            actions.appendChild(delBtn);
            headerRow.appendChild(actions);
            left.appendChild(headerRow);

            // wire buttons
            viewBtn.addEventListener('click', async () => {
                try {
                    // go back to builder with same flowchart and mode=run, then trigger loading of this execution
                    const url = new URL('/', window.location.origin);
                    if (flowDisplay && flowDisplay !== 'default') url.searchParams.set('flowchart', flowDisplay);
                    url.searchParams.set('mode', 'run');
                    // add special flag so builder loads this execution on arrival
                    url.searchParams.set('executionId', exec.execution_id);
                    window.location.href = url.pathname + '?' + url.searchParams.toString();
                } catch(e) {
                    console.error('[dm] failed to navigate to view execution', e);
                }
            });
            delBtn.addEventListener('click', async () => {
                try {
                    if (!confirm('delete this execution from history?')) return;
                    const resp = await fetch(`/api/history/${exec.execution_id}?flowchart_name=${encodeURIComponent(flowFilename)}`, { method: 'DELETE' });
                    const json = await resp.json();
                    if (json && json.status === 'success') {
                        // simple refresh after delete
                        window.location.reload();
                    } else {
                        alert('failed to delete execution');
                    }
                } catch(e) {
                    alert('error deleting execution');
                }
            });

            // stats list with icons to improve readability
            const stats = el('div','dm_stats');
            function stat(iconName, label, value){
                const s = el('div','dm_stat');
                const ic = el('span','material-icons dm_stat_icon', iconName);
                const txt = el('div','dm_stat_text');
                txt.appendChild(el('div','dm_stat_label', label));
                txt.appendChild(el('div','dm_stat_value', value));
                s.appendChild(ic);
                s.appendChild(txt);
                return s;
            }
            const nodesText = `${exec.successful_nodes || 0} / ${exec.total_nodes || 0}`;
            stats.appendChild(stat('timeline','nodes', nodesText));
            // use a clearer success icon
            stats.appendChild(stat('check_circle','success %', String(exec.success_percentage ?? 0) + '%'));
            stats.appendChild(stat('schedule','elapsed', exec.execution_time || '-'));
            // format timestamp for better readability
            const runAtDisplay = formatTimestamp(exec.timestamp);
            stats.appendChild(stat('event','run at', runAtDisplay));
            if (exec.status === 'failed' && exec.failed_node) {
                stats.appendChild(stat('error','failed node', exec.failed_node));
            }
            left.appendChild(stats);

            // right: data table of data_save outputs, 1 row per data_save
            const right = el('div','dm_right');
            
            // create the data bar with search and export
            const dataBar = el('div','dm_data_bar');
            const searchContainer = el('div','dm_search_container');
            const searchIcon = el('span','material-icons dm_search_icon','search');
            const searchInput = el('input','dm_search_input');
            searchInput.type = 'text';
            searchInput.placeholder = 'search data...';
            searchContainer.appendChild(searchIcon);
            searchContainer.appendChild(searchInput);
            
            // add matching count display
            const matchCount = el('div','dm_match_count');
            matchCount.textContent = '0 matching of 0 total variables';
            matchCount.style.display = 'none'; // hide initially
            searchContainer.appendChild(matchCount);
            
            const exportBtn = el('button','btn btn_primary dm_export_btn','<span class="material-icons">download</span><span>Export</span>');
            
            dataBar.appendChild(searchContainer);
            dataBar.appendChild(exportBtn);
            right.appendChild(dataBar);
            
            const content = el('div','dm_data_content');
            const table = el('table','dm_table');
            // enforce column sizing so value column expands to fill remaining width
            const colgroup = document.createElement('colgroup');
            const col1 = document.createElement('col'); col1.style.width = '22%';
            const col2 = document.createElement('col'); col2.style.width = '24%';
            // remaining width after first two percentage columns and fixed actions column
            const col3 = document.createElement('col'); col3.style.width = 'calc(100% - 46% - 160px)';
            const col4 = document.createElement('col'); col4.style.width = '160px';
            colgroup.appendChild(col1); colgroup.appendChild(col2); colgroup.appendChild(col3); colgroup.appendChild(col4);
            table.appendChild(colgroup);
            const thead = el('thead');
            thead.innerHTML = `<tr>
                <th class="dm_col_var_name">data name</th>
                <th class="dm_col_py_name">python variable</th>
                <th class="dm_col_value">value</th>
                <th class="dm_col_actions"></th>
            </tr>`;
            table.appendChild(thead);
            const tbody = el('tbody');
            const detail = details[idx];
            // helpers for type column
            function inferType(value){
                if (value === null) return 'null';
                if (typeof value === 'undefined') return 'undefined';
                if (Array.isArray(value)) return 'array';
                if (typeof value === 'number') return Number.isInteger(value) ? 'integer' : 'float';
                if (typeof value === 'string') return 'string';
                if (typeof value === 'boolean') return 'boolean';
                if (value && typeof value === 'object') return 'object';
                return 'unknown';
            }
            function normalizeTypeName(raw){
                const t = String(raw || '-').toLowerCase();
                if (t.includes('int')) return 'integer';
                if (t.includes('float') || t.includes('double')) return 'float';
                if (t.includes('list') || t.includes('array')) return 'array';
                if (t.includes('dict') || t.includes('obj')) return 'object';
                if (t.includes('str') || t === 'text' || t === 'char') return 'string';
                if (t.includes('bool')) return 'boolean';
                if (t === 'none' || t === 'null') return 'null';
                return t || 'unknown';
            }
            function typeTag(typeText){
                const normalized = normalizeTypeName(typeText);
                const s = document.createElement('span');
                s.className = 'dm_type_tag dm_type_tag_' + normalized;
                s.textContent = normalized;
                return s;
            }
            if (detail && detail.execution_data) {
                // prefer normalized array if available
                const dsNorm = Array.isArray(detail.execution_data.data_saves) ? detail.execution_data.data_saves : null;
                if (dsNorm && dsNorm.length > 0) {
                    dsNorm.forEach(r => {
                        const tr = document.createElement('tr');
                        const td1 = document.createElement('td'); td1.className='dm_col_var_name'; td1.textContent = r.node_name || '-';
                        const td2 = document.createElement('td'); td2.className='dm_col_py_name'; td2.textContent = r.variable_name || '-';
                        const td3 = document.createElement('td'); td3.className='dm_col_value'; td3.textContent = Array.isArray(r.variable_content) ? String(r.variable_content[1]) : '';
                        const td4 = document.createElement('td'); td4.className='dm_col_actions';
                        const typeText = Array.isArray(r.variable_content) ? String(r.variable_content[0] || '-') : '-';
                        td4.appendChild(typeTag(typeText));
                        const openBtn = el('button','btn btn_secondary dm_open_btn','<span class="material-icons">open_in_new</span>');
                        // open detail view for this variable
                        openBtn.addEventListener('click', () => {
                            openVariableDetail({
                                dataName: r.node_name || '-',
                                pythonVar: r.variable_name || '-',
                                typeText: typeText,
                                value: Array.isArray(r.variable_content) ? r.variable_content[1] : ''
                            });
                        });
                        td4.appendChild(openBtn);
                        tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3); tr.appendChild(td4);
                        tbody.appendChild(tr);
                    });
                } else if (Array.isArray(detail.execution_data.results)) {
                    const results = detail.execution_data.results;
                    // fallback: infer from synthesized results
                    const dsRows = results.filter(r => r.function_name === 'data_save' || (r.node_name && r.python_file && r.return_value && typeof r.return_value === 'object' && Object.keys(r.return_value).length === 1 && detail.execution_data.flowchart_state && detail.execution_data.flowchart_state.nodes && detail.execution_data.flowchart_state.nodes.find(n=>n.id===r.node_id && n.type==='data_save')));
                    if (dsRows.length === 0) {
                        tbody.appendChild(el('tr','', '<td colspan="4" style="opacity:.7; text-align: center;">no saved data</td>'));
                    } else {
                        dsRows.forEach(r => {
                            const keys = (r.return_value && typeof r.return_value === 'object') ? Object.keys(r.return_value) : [];
                            const dataName = (r.data_save && r.data_save.data_name) || (keys[0] || '-');
                            const pyVar = (r.data_save && r.data_save.variable_name) || (keys[0] || '-');
                            const value = keys.length ? r.return_value[keys[0]] : null;
                            const tr = document.createElement('tr');
                            const td1 = document.createElement('td'); td1.className='dm_col_var_name'; td1.textContent = dataName || '-';
                            const td2 = document.createElement('td'); td2.className='dm_col_py_name'; td2.textContent = pyVar || '-';
                            const td3 = document.createElement('td'); td3.className='dm_col_value'; td3.textContent = (value === null || typeof value === 'undefined') ? 'null' : (typeof value === 'object' ? JSON.stringify(value) : String(value));
                            const td4 = document.createElement('td'); td4.className='dm_col_actions';
                            const typeText = inferType(value);
                            td4.appendChild(typeTag(typeText));
                            const openBtn = el('button','btn btn_secondary dm_open_btn','<span class="material-icons">open_in_new</span>');
                            openBtn.addEventListener('click', () => {
                                openVariableDetail({
                                    dataName: dataName || '-',
                                    pythonVar: pyVar || '-',
                                    typeText: typeText,
                                    value
                                });
                            });
                            td4.appendChild(openBtn);
                            tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3); tr.appendChild(td4);
                            tbody.appendChild(tr);
                        });
                    }
                } else {
                    tbody.appendChild(el('tr','', '<td colspan="4" style="opacity:.7">no saved data</td>'));
                }
                            } else {
                    tbody.appendChild(el('tr','', '<td colspan="4" style="opacity:.7; text-align: center;">no data</td>'));
                }
            table.appendChild(tbody);
            content.appendChild(table);
            right.appendChild(content);

            // failure info: full width block under left and right when execution failed
            const failureInfo = el('div','dm_failure_info');
            failureInfo.style.display = 'none'; // hide by default

            if (exec.status === 'failed') {
                // try to resolve failure details from detailed execution data
                let failedResult = null;
                try {
                    const results = detail && detail.execution_data && Array.isArray(detail.execution_data.results)
                        ? detail.execution_data.results
                        : [];
                    failedResult = results.find(r => r && r.success === false) || null;
                } catch(_) { /* noop */ }

                // build ui only if we have something meaningful to show
                const nodeName = (failedResult && failedResult.node_name) || (exec.failed_node) || null;
                const pythonPath = (failedResult && failedResult.python_file) || null;
                const errorMessage = (failedResult && failedResult.error) || (detail && detail.execution_data && detail.execution_data.error_message) || null;

                if (nodeName || pythonPath || errorMessage) {
                    // title row
                    const title = el('div','dm_failure_title');
                    const icon = el('span','material-icons dm_failure_icon','error');
                    const titleText = el('div','', 'execution failed');
                    title.appendChild(icon);
                    title.appendChild(titleText);
                    failureInfo.appendChild(title);

                    // body grid
                    const body = el('div','dm_failure_body');
                    function addRow(label, value){
                        const l = el('div','dm_failure_label', label);
                        const v = el('div','dm_failure_value');
                        v.textContent = value || '-';
                        body.appendChild(l);
                        body.appendChild(v);
                    }
                    addRow('node name', nodeName || '-');
                    addRow('python script path', pythonPath || '-');
                    addRow('error message', errorMessage || '-');
                    failureInfo.appendChild(body);
                    // keep failure details hidden by default; toggle via status badge click
                    failureInfo.style.display = 'none';
                }
            }

            // filter table rows based on search input (matches data name and python variable)
            if (statusBadge === 'failed') {
                try {
                    statusEl.style.cursor = 'pointer';
                    statusEl.title = 'toggle failure details';
                    statusEl.addEventListener('click', () => {
                        // ensure failure info is appended to the row before toggling
                        if (!row.contains(failureInfo)) {
                            row.appendChild(failureInfo);
                        }
                        const isHidden = failureInfo.style.display === 'none';
                        failureInfo.style.display = isHidden ? '' : 'none';
                    });
                } catch(_) {}
            }

            // detail view renderer for a single variable
            function openVariableDetail(info){
                // hide all execution rows
                const allRows = Array.from(document.querySelectorAll('.dm_row, .dm_failure_info'));
                allRows.forEach(r => { r.style.display = 'none'; });

                // build detail container once per page (reuse on subsequent opens)
                let detailContainer = document.querySelector('.dm_detail_container');
                if (!detailContainer) {
                    detailContainer = el('div','dm_detail_container');
                    container.appendChild(detailContainer);
                }
                detailContainer.innerHTML = '';

                // top block: metadata
                const top = el('div','dm_detail_block');
                const meta = el('div','dm_detail_meta');
                function addMeta(label, node){
                    meta.appendChild(el('div','dm_detail_label', label));
                    const valueWrap = el('div','dm_detail_value');
                    valueWrap.appendChild(node);
                    meta.appendChild(valueWrap);
                }
                addMeta('data name', el('div','', info.dataName));
                addMeta('python variable', el('div','', info.pythonVar));
                const typeWrap = el('div','');
                typeWrap.appendChild(typeTag(info.typeText));
                addMeta('type', typeWrap);
                // add a back button to return to list view
                const backBtn = el('button','btn btn_secondary dm_row_btn','<span class="material-icons">arrow_back</span><span class="btn_label">back</span>');
                backBtn.style.marginTop = '12px';
                backBtn.addEventListener('click', () => {
                    // remove detail view and show all rows again
                    if (detailContainer) detailContainer.remove();
                    allRows.forEach(r => { r.style.display = ''; });
                });
                top.appendChild(meta);
                top.appendChild(backBtn);

                // bottom block: content
                const bottom = el('div','dm_detail_block');
                const pre = document.createElement('pre');
                try {
                    pre.textContent = typeof info.value === 'object' ? JSON.stringify(info.value, null, 2) : String(info.value);
                } catch(_) {
                    pre.textContent = String(info.value);
                }
                bottom.appendChild(pre);

                detailContainer.appendChild(top);
                detailContainer.appendChild(bottom);
            }

            // filter table rows based on search input (matches data name and python variable)
            searchInput.addEventListener('input', () => {
                const q = (searchInput.value || '').trim().toLowerCase();
                const rows = Array.from(tbody.querySelectorAll('tr'));
                let visibleCount = 0;
                const totalCount = rows.length;
                
                // show/hide match count based on whether there's a search query
                if (q) {
                    matchCount.style.display = '';
                } else {
                    matchCount.style.display = 'none';
                }
                
                // remove any existing no results row
                const existingNoResults = tbody.querySelector('.dm_no_results');
                if (existingNoResults) {
                    existingNoResults.remove();
                }
                
                rows.forEach(tr => {
                    const nameCell = tr.querySelector('.dm_col_var_name');
                    const pyCell = tr.querySelector('.dm_col_py_name');
                    const nameText = nameCell ? String(nameCell.textContent || '').toLowerCase() : '';
                    const pyText = pyCell ? String(pyCell.textContent || '').toLowerCase() : '';
                    const match = !q || nameText.includes(q) || pyText.includes(q);
                    tr.style.display = match ? '' : 'none';
                    if (match) visibleCount++;
                });
                
                // update match count display
                matchCount.textContent = `${visibleCount} matching of ${totalCount} total variables`;
                
                // show no results message if no rows match and search is active
                if (q && visibleCount === 0) {
                    const noResultsRow = el('tr', 'dm_no_results');
                    noResultsRow.innerHTML = '<td colspan="5" style="text-align: center; opacity: 0.7; padding: 16px;">no results found</td>';
                    tbody.appendChild(noResultsRow);
                }
            });

            row.appendChild(left);
            row.appendChild(right);
            // append all sections to the row
            container.appendChild(row);
            if (failureInfo && failureInfo.style.display !== 'none') {
                row.appendChild(failureInfo);
            }
            try {
                const cCount = container.childElementCount;
                const rRect = row.getBoundingClientRect();
                console.log('[dm] row appended', { childCount: cCount, rowRect: { x: rRect.x, y: rRect.y, w: rRect.width, h: rRect.height } });
            } catch(_) {}
        });
        
        // update status bar with execution count
        const executionCount = executions.length;
        const statusText = document.getElementById('status_text');
        if (statusText) {
            statusText.textContent = `${executionCount} execution${executionCount !== 1 ? 's' : ''}`;
        }

        // show and wire clear history button (reuse same api as settings page)
        const clearBtn = document.getElementById('clear_history_status_btn');
        if (clearBtn) {
            // show only on data matrix page
            clearBtn.style.display = '';
            clearBtn.addEventListener('click', async () => {
                try {
                    // confirm destructive action
                    if (!confirm('clear all executions for this flowchart?')) return;
                    clearBtn.disabled = true;
                    if (statusText) statusText.textContent = 'clearing…';
                    const resp = await fetch('/api/history/clear', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ flowchart_name: flowFilename })
                    });
                    const json = await resp.json();
                    if (json && json.status === 'success') {
                        // refresh to reflect empty history
                        window.location.reload();
                    } else {
                        alert(json && json.message ? json.message : 'failed to clear history');
                        clearBtn.disabled = false;
                        if (statusText) statusText.textContent = `${executionCount} execution${executionCount !== 1 ? 's' : ''}`;
                    }
                } catch (e) {
                    alert('error clearing history');
                    clearBtn.disabled = false;
                    if (statusText) statusText.textContent = `${executionCount} execution${executionCount !== 1 ? 's' : ''}`;
                }
            });
        }
    })().catch(err => { try { console.error('[dm] fatal init error', err); } catch(_) {} });
    </script>
</body>
</html>

