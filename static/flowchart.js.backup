// flowchart builder javascript with multi-select and grouping
class FlowchartBuilder {
    constructor() {
        this.nodes = [];
        this.links = [];
        this.groups = [];
        this.selectedNodes = new Set();
        this.selectedLink = null;
        this.selectedGroup = null;
        this.draggedNode = null;
        this.nodeCounter = 0;
        this.groupCounter = 0;
        this.isConnecting = false;
        this.sourceNode = null;
        this.connectionLine = null;
        this.currentEditingNode = null;
        this.isDragging = false;
        this.dragAnimationFrame = null;
        
        // pan and zoom
        this.transform = d3.zoomIdentity;
        
        // autosave timer
        this.autosaveTimer = null;
        this.autosaveDelay = 2000; // 2 seconds
        
        this.initSvg();
        this.setupEventListeners();
        this.loadFlowchart();
        this.updatePropertiesSidebar();
    }

    initSvg() {
        this.svg = d3.select('#flowchart_canvas');
        this.width = window.innerWidth - 600; // subtract both sidebars
        this.height = window.innerHeight - 32; // subtract status bar only
        
        this.svg
            .attr('width', this.width)
            .attr('height', this.height);

        // setup zoom and pan
        this.zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .filter((event) => {
                // only allow zoom/pan when not dragging nodes or connecting
                // also prevent zoom on right-click
                return !this.isDragging && !this.isConnecting && event.button !== 2;
            })
            .on('zoom', (event) => {
                this.transform = event.transform;
                this.zoomGroup.attr('transform', event.transform);
            });

        this.svg.call(this.zoom);

        // main zoom group
        this.zoomGroup = this.svg.select('#zoom_group');

        // define arrow marker
        this.svg.append('defs')
            .append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 8)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#3d3d3d');

        // create groups for different elements
        this.groupsGroup = this.zoomGroup.append('g').attr('class', 'groups');
        this.linkGroup = this.zoomGroup.append('g').attr('class', 'links');
        this.nodeGroup = this.zoomGroup.append('g').attr('class', 'nodes');

        // handle canvas clicks
        this.svg.on('click', (event) => {
            if (event.target === this.svg.node()) {
                const [x, y] = d3.pointer(event, this.zoomGroup.node());
                this.addNode(x, y);
                this.clearSelections();
            }
        });

        // handle context menu
        this.svg.on('contextmenu', (event) => {
            event.preventDefault();
            this.hideContextMenu();
        });
    }

    setupEventListeners() {
        // sidebar buttons
        document.getElementById('build_btn').addEventListener('click', () => this.buildAction());
        document.getElementById('run_btn').addEventListener('click', () => this.runAction());
        document.getElementById('add_node_btn').addEventListener('click', () => this.addNodeAtCenter());

        // context menu
        document.getElementById('edit_node').addEventListener('click', () => this.editNode());
        document.getElementById('delete_node').addEventListener('click', () => this.deleteNode());

        // single node properties
        document.getElementById('save_node_properties').addEventListener('click', () => this.saveNodeProperties());
        document.getElementById('delete_node_from_sidebar').addEventListener('click', () => this.deleteNodeFromSidebar());

        // multi-select properties
        document.getElementById('create_group_btn').addEventListener('click', () => this.createGroup());
        document.getElementById('align_nodes_btn').addEventListener('click', () => this.alignNodes());
        document.getElementById('delete_selected_nodes').addEventListener('click', () => this.deleteSelectedNodes());

        // group properties
        document.getElementById('save_group_properties').addEventListener('click', () => this.saveGroupProperties());
        document.getElementById('ungroup_nodes').addEventListener('click', () => this.ungroupNodes());
        document.getElementById('delete_group').addEventListener('click', () => this.deleteGroup());

        // hide context menu on click elsewhere
        document.addEventListener('click', () => this.hideContextMenu());

        // handle window resize
        window.addEventListener('resize', () => this.handleResize());

        // keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Delete') {
                if (this.selectedNodes.size > 0) {
                    this.deleteSelectedNodes();
                } else if (this.selectedLink) {
                    this.deleteSelectedLink();
                } else if (this.selectedGroup) {
                    this.deleteGroup();
                }
            }
            if (event.key === 'Escape') {
                this.cancelConnection();
                this.clearSelections();
            }
            if (event.key === 'g' && event.ctrlKey && this.selectedNodes.size > 1) {
                event.preventDefault();
                this.createGroup();
            }
        });
    }

    addNode(x, y, name = null, data = {}) {
        const nodeName = name || `python_file_${++this.nodeCounter}.py`;
        const node = {
            id: Date.now() + Math.random(),
            x: x,
            y: y,
            name: nodeName,
            type: data.type || 'python_file',
            pythonFile: data.pythonFile || '',
            description: data.description || '',
            groupId: data.groupId || null,
            ...data
        };

        this.nodes.push(node);
        this.updateDisplay();
        this.updateStatus(`added node: ${nodeName}`);
        this.scheduleAutosave();
    }

    addNodeAtCenter() {
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        // transform screen coordinates to world coordinates
        const [x, y] = this.transform.invert([centerX, centerY]);
        this.addNode(x, y);
    }

    // calculate text width for responsive node sizing
    getTextWidth(text, fontSize = 14) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        context.font = `${fontSize}px Roboto, sans-serif`;
        return context.measureText(text).width;
    }

    getNodeWidth(text) {
        const textWidth = this.getTextWidth(text);
        const padding = 40; // 20px padding on each side
        const minWidth = 120;
        return Math.max(minWidth, textWidth + padding);
    }

    updateDisplay() {
        this.renderGroups();
        this.renderNodes();
        this.renderLinks();
        this.updateNodeCount();
    }

    renderGroups() {
        const groupSelection = this.groupsGroup
            .selectAll('.group-container')
            .data(this.groups, d => d.id);

        // enter new groups
        const groupEnter = groupSelection.enter()
            .append('g')
            .attr('class', 'group-container');

        // add group rectangle
        groupEnter.append('rect')
            .attr('class', 'group_container')
            .attr('rx', 12);

        // add group label
        groupEnter.append('text')
            .attr('class', 'group_label')
            .attr('dy', '-8px');

        // merge enter and update selections
        const groupMerge = groupEnter.merge(groupSelection);

        // update group positions and sizes
        groupMerge.each((d, i, nodes) => {
            const groupNodes = this.nodes.filter(n => n.groupId === d.id);
            if (groupNodes.length === 0) return;

            // calculate group bounds
            const bounds = this.calculateGroupBounds(groupNodes);
            const padding = 20;

            // update rectangle
            d3.select(nodes[i]).select('.group_container')
                .attr('x', bounds.minX - padding)
                .attr('y', bounds.minY - padding)
                .attr('width', bounds.width + 2 * padding)
                .attr('height', bounds.height + 2 * padding);

            // update label
            d3.select(nodes[i]).select('.group_label')
                .attr('x', bounds.minX - padding + 8)
                .attr('y', bounds.minY - padding)
                .text(d.name);
        });

        // add click handler for groups
        groupMerge.on('click', (event, d) => {
            event.stopPropagation();
            this.selectGroup(d);
        });

        // remove old groups
        groupSelection.exit().remove();
    }

    calculateGroupBounds(nodes) {
        const positions = nodes.map(n => ({
            x: n.x,
            y: n.y,
            width: n.width || 120,
            height: 60
        }));

        const minX = Math.min(...positions.map(p => p.x - p.width/2));
        const maxX = Math.max(...positions.map(p => p.x + p.width/2));
        const minY = Math.min(...positions.map(p => p.y - p.height/2));
        const maxY = Math.max(...positions.map(p => p.y + p.height/2));

        return {
            minX,
            minY,
            width: maxX - minX,
            height: maxY - minY
        };
    }

    renderNodes() {
        const nodeSelection = this.nodeGroup
            .selectAll('.node-group')
            .data(this.nodes, d => d.id);

        // enter new nodes
        const nodeEnter = nodeSelection.enter()
            .append('g')
            .attr('class', 'node-group')
            .attr('transform', d => `translate(${d.x},${d.y})`);

        // add rectangle
        nodeEnter.append('rect')
            .attr('class', 'node')
            .attr('height', 60)
            .attr('y', -30)
            .attr('rx', 8);

        // add text
        nodeEnter.append('text')
            .attr('class', 'node_text')
            .attr('dy', '.35em')
            .text(d => d.name);

        // add connection dots (4 dots on edges)
        const dotData = [
            { side: 'top', getPos: (width) => ({ x: 0, y: -30 }) },
            { side: 'right', getPos: (width) => ({ x: width/2, y: 0 }) },
            { side: 'bottom', getPos: (width) => ({ x: 0, y: 30 }) },
            { side: 'left', getPos: (width) => ({ x: -width/2, y: 0 }) }
        ];

        dotData.forEach((dotInfo) => {
            nodeEnter.append('circle')
                .attr('class', 'connection_dot')
                .attr('r', 6)
                .attr('data-side', dotInfo.side)
                .style('cursor', 'crosshair');
        });

        // merge enter and update selections
        const nodeMerge = nodeEnter.merge(nodeSelection);

        // update positions
        nodeMerge.attr('transform', d => `translate(${d.x},${d.y})`);

        // update text and calculate width
        nodeMerge.select('text').text(d => d.name);
        
        // update rectangle width based on text
        nodeMerge.select('.node').attr('width', d => {
            const width = this.getNodeWidth(d.name);
            d.width = width; // store width on node data
            return width;
        }).attr('x', d => -d.width/2);

        // update connection dot positions
        nodeMerge.selectAll('.connection_dot').attr('cx', function(d) {
            const side = d3.select(this).attr('data-side');
            const width = d.width || 120;
            switch(side) {
                case 'top':
                case 'bottom':
                    return 0;
                case 'right':
                    return width/2;
                case 'left':
                    return -width/2;
                default:
                    return 0;
            }
        }).attr('cy', function(d) {
            const side = d3.select(this).attr('data-side');
            switch(side) {
                case 'top':
                    return -30;
                case 'bottom':
                    return 30;
                case 'right':
                case 'left':
                    return 0;
                default:
                    return 0;
            }
        });

        // add event listeners to nodes
        nodeMerge.select('.node')
            .on('click', (event, d) => {
                event.stopPropagation();
                this.handleNodeClick(event, d);
            })
            .on('contextmenu', (event, d) => {
                event.preventDefault();
                event.stopPropagation();
                this.showContextMenu(event.pageX, event.pageY, d);
            })
            .call(d3.drag()
                .container(this.zoomGroup.node()) // use zoom group as container for proper coordinates
                .on('start', (event, d) => this.dragStart(event, d))
                .on('drag', (event, d) => this.dragging(event, d))
                .on('end', (event, d) => this.dragEnd(event, d))
            );

        // add event listeners to connection dots
        nodeMerge.selectAll('.connection_dot')
            .on('mousedown', (event, d) => {
                event.stopPropagation();
                this.startConnectionFromDot(event, d);
            })
            .call(d3.drag()
                .on('start', (event, d) => this.startConnectionDrag(event, d))
                .on('drag', (event, d) => this.dragConnection(event, d))
                .on('end', (event, d) => this.endConnectionDrag(event, d))
            );

        // remove old nodes
        nodeSelection.exit().remove();

        // update node styles
        this.updateNodeStyles();
    }

    handleNodeClick(event, node) {
        if (event.shiftKey) {
            // multi-select mode
            if (this.selectedNodes.has(node.id)) {
                this.selectedNodes.delete(node.id);
            } else {
                this.selectedNodes.add(node.id);
            }
        } else {
            // single select mode
            this.selectedNodes.clear();
            this.selectedNodes.add(node.id);
        }
        
        this.selectedLink = null;
        this.selectedGroup = null;
        this.updateNodeStyles();
        this.updatePropertiesSidebar();
        this.updateStatus(`selected ${this.selectedNodes.size} node(s)`);
    }

    renderLinks() {
        const linkSelection = this.linkGroup
            .selectAll('.link')
            .data(this.links, d => `${d.source}-${d.target}`);

        // enter new links
        linkSelection.enter()
            .append('path')
            .attr('class', 'link')
            .on('click', (event, d) => {
                event.stopPropagation();
                this.selectLink(d);
            })
            .merge(linkSelection)
            .attr('d', d => {
                const sourceNode = this.nodes.find(n => n.id === d.source);
                const targetNode = this.nodes.find(n => n.id === d.target);
                if (!sourceNode || !targetNode) return '';
                
                return `M${sourceNode.x},${sourceNode.y} L${targetNode.x},${targetNode.y}`;
            })
            .classed('selected', d => this.selectedLink && 
                d.source === this.selectedLink.source && 
                d.target === this.selectedLink.target);

        // remove old links
        linkSelection.exit().remove();
    }

    selectLink(link) {
        this.clearSelections();
        this.selectedLink = link;
        this.updateDisplay();
        this.updatePropertiesSidebar();
        this.updateStatus('link selected - press delete to remove');
    }

    selectGroup(group) {
        this.clearSelections();
        this.selectedGroup = group;
        this.updatePropertiesSidebar();
        this.updateStatus(`selected group: ${group.name}`);
    }

    clearSelections() {
        this.selectedNodes.clear();
        this.selectedLink = null;
        this.selectedGroup = null;
        this.currentEditingNode = null;
        this.updateNodeStyles();
        this.updateDisplay();
        this.updatePropertiesSidebar();
    }

    updateNodeStyles() {
        this.nodeGroup.selectAll('.node')
            .classed('selected', d => this.selectedNodes.has(d.id) && this.selectedNodes.size === 1)
            .classed('multi_selected', d => this.selectedNodes.has(d.id) && this.selectedNodes.size > 1);
    }

    // multi-select and grouping methods
    createGroup() {
        if (this.selectedNodes.size < 2) {
            this.updateStatus('select at least 2 nodes to create a group');
            return;
        }

        const groupId = Date.now() + Math.random();
        const group = {
            id: groupId,
            name: `group_${++this.groupCounter}`,
            description: '',
            nodeIds: Array.from(this.selectedNodes)
        };

        // assign group id to selected nodes
        this.nodes.forEach(node => {
            if (this.selectedNodes.has(node.id)) {
                node.groupId = groupId;
            }
        });

        this.groups.push(group);
        this.organizeGroupNodes(group);
        this.selectedGroup = group;
        this.selectedNodes.clear();
        
        this.updateDisplay();
        this.updatePropertiesSidebar();
        this.updateStatus(`created group: ${group.name}`);
        this.scheduleAutosave();
    }

    organizeGroupNodes(group) {
        const groupNodes = this.nodes.filter(n => n.groupId === group.id);
        if (groupNodes.length === 0) return;

        // calculate center point of selected nodes
        const centerX = groupNodes.reduce((sum, n) => sum + n.x, 0) / groupNodes.length;
        const centerY = groupNodes.reduce((sum, n) => sum + n.y, 0) / groupNodes.length;

        // arrange nodes in a grid pattern
        const cols = Math.ceil(Math.sqrt(groupNodes.length));
        const spacing = 150;

        groupNodes.forEach((node, index) => {
            const row = Math.floor(index / cols);
            const col = index % cols;
            const offsetX = (col - (cols - 1) / 2) * spacing;
            const offsetY = (row - Math.floor(groupNodes.length / cols) / 2) * spacing;
            
            node.x = centerX + offsetX;
            node.y = centerY + offsetY;
        });
    }

    alignNodes() {
        if (this.selectedNodes.size < 2) {
            this.updateStatus('select at least 2 nodes to align');
            return;
        }

        const selectedNodeObjects = this.nodes.filter(n => this.selectedNodes.has(n.id));
        const centerY = selectedNodeObjects.reduce((sum, n) => sum + n.y, 0) / selectedNodeObjects.length;

        selectedNodeObjects.forEach(node => {
            node.y = centerY;
        });

        this.updateDisplay();
        this.updateStatus('nodes aligned horizontally');
        this.scheduleAutosave();
    }

    ungroupNodes() {
        if (!this.selectedGroup) return;

        // remove group id from nodes
        this.nodes.forEach(node => {
            if (node.groupId === this.selectedGroup.id) {
                node.groupId = null;
            }
        });

        // remove group
        this.groups = this.groups.filter(g => g.id !== this.selectedGroup.id);
        this.selectedGroup = null;

        this.updateDisplay();
        this.updatePropertiesSidebar();
        this.updateStatus('group disbanded');
        this.scheduleAutosave();
    }

    deleteGroup() {
        if (!this.selectedGroup) return;

        // remove nodes in group
        const groupNodeIds = this.nodes.filter(n => n.groupId === this.selectedGroup.id).map(n => n.id);
        this.nodes = this.nodes.filter(n => n.groupId !== this.selectedGroup.id);
        
        // remove associated links
        this.links = this.links.filter(l => 
            !groupNodeIds.includes(l.source) && !groupNodeIds.includes(l.target)
        );

        // remove group
        this.groups = this.groups.filter(g => g.id !== this.selectedGroup.id);
        this.selectedGroup = null;

        this.updateDisplay();
        this.updatePropertiesSidebar();
        this.updateStatus('group deleted');
        this.scheduleAutosave();
    }

    deleteSelectedNodes() {
        if (this.selectedNodes.size === 0) return;

        const nodeIds = Array.from(this.selectedNodes);
        
        // remove nodes
        this.nodes = this.nodes.filter(n => !this.selectedNodes.has(n.id));
        
        // remove associated links
        this.links = this.links.filter(l => 
            !nodeIds.includes(l.source) && !nodeIds.includes(l.target)
        );

        this.selectedNodes.clear();
        this.updateDisplay();
        this.updatePropertiesSidebar();
        this.updateStatus(`deleted ${nodeIds.length} node(s)`);
        this.scheduleAutosave();
    }

    // properties sidebar management
    updatePropertiesSidebar() {
        // hide all content panels
        document.querySelectorAll('.properties_content').forEach(panel => {
            panel.classList.remove('active');
        });

        if (this.selectedNodes.size === 1) {
            // single node selected
            const nodeId = Array.from(this.selectedNodes)[0];
            const node = this.nodes.find(n => n.id === nodeId);
            this.currentEditingNode = node;
            
            document.getElementById('single_node_properties').classList.add('active');
            document.getElementById('properties_title').textContent = 'node properties';
            
            // populate form fields
            document.getElementById('node_name').value = node.name || '';
            document.getElementById('python_file').value = node.pythonFile || '';
            document.getElementById('node_description').value = node.description || '';
            document.getElementById('node_type').value = node.type || 'python_file';
            
        } else if (this.selectedNodes.size > 1) {
            // multiple nodes selected
            document.getElementById('multi_select_properties').classList.add('active');
            document.getElementById('properties_title').textContent = `${this.selectedNodes.size} nodes selected`;
            
            // populate selected nodes list
            this.updateSelectedNodesList();
            
        } else if (this.selectedGroup) {
            // group selected
            document.getElementById('group_properties').classList.add('active');
            document.getElementById('properties_title').textContent = 'group properties';
            
            document.getElementById('group_name').value = this.selectedGroup.name || '';
            document.getElementById('group_description').value = this.selectedGroup.description || '';
            this.updateGroupMembersList();
            
        } else {
            // nothing selected
            document.getElementById('default_properties').classList.add('active');
            document.getElementById('properties_title').textContent = 'properties';
        }
    }

    updateSelectedNodesList() {
        const container = document.getElementById('selected_nodes_list');
        container.innerHTML = '';
        
        this.selectedNodes.forEach(nodeId => {
            const node = this.nodes.find(n => n.id === nodeId);
            if (node) {
                const item = document.createElement('div');
                item.style.cssText = 'padding: 4px 8px; margin: 2px 0; background: var(--surface-color); border-radius: 4px; font-size: 0.875rem;';
                item.textContent = node.name;
                container.appendChild(item);
            }
        });
    }

    updateGroupMembersList() {
        const container = document.getElementById('group_members_list');
        container.innerHTML = '';
        
        if (this.selectedGroup) {
            const groupNodes = this.nodes.filter(n => n.groupId === this.selectedGroup.id);
            groupNodes.forEach(node => {
                const item = document.createElement('div');
                item.style.cssText = 'padding: 4px 8px; margin: 2px 0; background: var(--surface-color); border-radius: 4px; font-size: 0.875rem;';
                item.textContent = node.name;
                container.appendChild(item);
            });
        }
    }

    // existing methods continue...
    startConnectionFromDot(event, nodeData) {
        event.stopPropagation();
        this.isConnecting = true;
        this.sourceNode = nodeData;
        
        // create temporary connection line
        this.connectionLine = this.zoomGroup.append('line')
            .attr('class', 'connection_line')
            .attr('x1', nodeData.x)
            .attr('y1', nodeData.y)
            .attr('x2', nodeData.x)
            .attr('y2', nodeData.y);

        this.updateStatus(`connecting from ${nodeData.name} - click target node or press escape to cancel`);
    }

    startConnectionDrag(event, nodeData) {
        this.startConnectionFromDot(event, nodeData);
    }

    dragConnection(event, nodeData) {
        if (this.connectionLine) {
            const [x, y] = d3.pointer(event, this.zoomGroup.node());
            this.connectionLine
                .attr('x2', x)
                .attr('y2', y);
        }
    }

    endConnectionDrag(event, nodeData) {
        if (!this.isConnecting) return;

        // find target node under cursor
        const [x, y] = d3.pointer(event, this.zoomGroup.node());
        const targetNode = this.findNodeAtPosition(x, y, nodeData.id);
        
        if (targetNode) {
            this.createLink(this.sourceNode.id, targetNode.id);
        }
        
        this.cancelConnection();
    }

    findNodeAtPosition(x, y, excludeId) {
        return this.nodes.find(node => {
            if (node.id === excludeId) return false;
            const dx = node.x - x;
            const dy = node.y - y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const nodeWidth = node.width || 120;
            return distance < Math.max(60, nodeWidth/2 + 10); // within node bounds
        });
    }

    cancelConnection() {
        this.isConnecting = false;
        this.sourceNode = null;
        if (this.connectionLine) {
            this.connectionLine.remove();
            this.connectionLine = null;
        }
        this.updateStatus('ready - click to add nodes, drag dots to connect');
    }

    createLink(sourceId, targetId) {
        // check if link already exists
        const exists = this.links.some(l => 
            (l.source === sourceId && l.target === targetId) ||
            (l.source === targetId && l.target === sourceId)
        );

        if (!exists) {
            this.links.push({
                source: sourceId,
                target: targetId
            });
            this.updateDisplay();
            this.updateStatus('link created');
            this.scheduleAutosave();
        } else {
            this.updateStatus('link already exists');
        }
    }

    dragStart(event, d) {
        this.isDragging = true;
        this.draggedNode = d;
        // disable zoom during drag
        this.svg.on('.zoom', null);
        
        // add dragging class to prevent CSS transitions
        this.nodeGroup
            .selectAll('.node-group')
            .filter(node => node.id === d.id)
            .select('.node')
            .classed('dragging', true);
        
        // store initial position for smooth dragging
        d.dragStartX = d.x;
        d.dragStartY = d.y;
    }

    dragging(event, d) {
        // update node position
        d.x = event.x;
        d.y = event.y;
        
        // cancel previous animation frame if it exists
        if (this.dragAnimationFrame) {
            cancelAnimationFrame(this.dragAnimationFrame);
        }
        
        // use requestAnimationFrame for smooth updates
        this.dragAnimationFrame = requestAnimationFrame(() => {
            this.updateDraggedNodePosition(d);
            this.dragAnimationFrame = null;
        });
    }

    dragEnd(event, d) {
        this.isDragging = false;
        this.draggedNode = null;
        
        // cancel any pending animation frame
        if (this.dragAnimationFrame) {
            cancelAnimationFrame(this.dragAnimationFrame);
            this.dragAnimationFrame = null;
        }
        
        // remove dragging class to re-enable CSS transitions
        this.nodeGroup
            .selectAll('.node-group')
            .filter(node => node.id === d.id)
            .select('.node')
            .classed('dragging', false);
        
        // re-enable zoom after drag
        this.svg.call(this.zoom);
        
        // clean up drag properties
        delete d.dragStartX;
        delete d.dragStartY;
        
        // final position update
        this.updateDraggedNodePosition(d);
        
        // update groups if node belongs to one
        if (d.groupId) {
            this.updateDisplay(); // full update to redraw group bounds
        }
        
        this.scheduleAutosave();
    }

    updateDraggedNodePosition(draggedNode) {
        // update only the dragged node's transform
        this.nodeGroup
            .selectAll('.node-group')
            .filter(d => d.id === draggedNode.id)
            .attr('transform', `translate(${draggedNode.x},${draggedNode.y})`);
        
        // update only the links connected to this node
        this.linkGroup
            .selectAll('.link')
            .filter(d => d.source === draggedNode.id || d.target === draggedNode.id)
            .attr('d', d => {
                const sourceNode = this.nodes.find(n => n.id === d.source);
                const targetNode = this.nodes.find(n => n.id === d.target);
                if (!sourceNode || !targetNode) return '';
                
                return `M${sourceNode.x},${sourceNode.y} L${targetNode.x},${targetNode.y}`;
            });
    }

    saveNodeProperties() {
        if (!this.currentEditingNode) return;

        const node = this.currentEditingNode;
        node.name = document.getElementById('node_name').value || node.name;
        node.pythonFile = document.getElementById('python_file').value || '';
        node.description = document.getElementById('node_description').value || '';
        node.type = document.getElementById('node_type').value || 'python_file';

        this.updateDisplay();
        this.updateStatus(`updated node: ${node.name}`);
        this.scheduleAutosave();
    }

    saveGroupProperties() {
        if (!this.selectedGroup) return;

        this.selectedGroup.name = document.getElementById('group_name').value || this.selectedGroup.name;
        this.selectedGroup.description = document.getElementById('group_description').value || '';

        this.updateDisplay();
        this.updateStatus(`updated group: ${this.selectedGroup.name}`);
        this.scheduleAutosave();
    }

    deleteNodeFromSidebar() {
        if (!this.currentEditingNode) return;
        
        this.selectedNodes.clear();
        this.selectedNodes.add(this.currentEditingNode.id);
        this.deleteSelectedNodes();
    }

    deleteSelectedLink() {
        if (!this.selectedLink) return;

        this.links = this.links.filter(l => 
            !(l.source === this.selectedLink.source && l.target === this.selectedLink.target)
        );

        this.updateStatus('link deleted');
        this.selectedLink = null;
        this.updateDisplay();
        this.updatePropertiesSidebar();
        this.scheduleAutosave();
    }

    showContextMenu(x, y, node) {
        this.selectedNodes.clear();
        this.selectedNodes.add(node.id);
        this.updateNodeStyles();
        
        const contextMenu = document.getElementById('context_menu');
        contextMenu.style.display = 'block';
        contextMenu.style.left = x + 'px';
        contextMenu.style.top = y + 'px';
    }

    hideContextMenu() {
        document.getElementById('context_menu').style.display = 'none';
    }

    editNode() {
        if (this.selectedNodes.size !== 1) return;
        const nodeId = Array.from(this.selectedNodes)[0];
        const node = this.nodes.find(n => n.id === nodeId);
        this.currentEditingNode = node;
        this.updatePropertiesSidebar();
        this.hideContextMenu();
    }

    deleteNode() {
        this.deleteSelectedNodes();
        this.hideContextMenu();
    }

    updateNodeCount() {
        document.getElementById('node_count').textContent = `nodes: ${this.nodes.length} | groups: ${this.groups.length}`;
    }

    updateStatus(message) {
        document.getElementById('status_text').textContent = message;
    }

    handleResize() {
        this.width = window.innerWidth - 600; // both sidebars
        this.height = window.innerHeight - 32; // only status bar now
        this.svg.attr('width', this.width).attr('height', this.height);
    }

    // autosave functionality
    scheduleAutosave() {
        // clear existing timer
        if (this.autosaveTimer) {
            clearTimeout(this.autosaveTimer);
        }
        
        // schedule new autosave
        this.autosaveTimer = setTimeout(() => {
            this.saveFlowchart(true); // true indicates autosave
        }, this.autosaveDelay);
    }

    // api methods
    async saveFlowchart(isAutosave = false) {
        const data = {
            nodes: this.nodes,
            links: this.links,
            groups: this.groups
        };

        try {
            const response = await fetch('/api/flowchart', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            });

            if (response.ok) {
                if (!isAutosave) {
                    this.updateStatus('flowchart saved successfully');
                }
            } else {
                this.updateStatus('error saving flowchart');
            }
        } catch (error) {
            console.error('error saving flowchart:', error);
            if (!isAutosave) {
                this.updateStatus('error saving flowchart');
            }
        }
    }

    async loadFlowchart() {
        try {
            const response = await fetch('/api/flowchart');
            if (response.ok) {
                const data = await response.json();
                this.nodes = data.nodes || [];
                this.links = data.links || [];
                this.groups = data.groups || [];
                
                // update counters
                if (this.nodes.length > 0) {
                    const maxCounter = Math.max(...this.nodes
                        .filter(n => n.name && n.name.startsWith('python_file_'))
                        .map(n => {
                            const match = n.name.match(/python_file_(\d+)\.py/);
                            return match ? parseInt(match[1]) : 0;
                        })
                    );
                    this.nodeCounter = maxCounter;
                }

                if (this.groups.length > 0) {
                    const maxGroupCounter = Math.max(...this.groups
                        .filter(g => g.name && g.name.startsWith('group_'))
                        .map(g => {
                            const match = g.name.match(/group_(\d+)/);
                            return match ? parseInt(match[1]) : 0;
                        })
                    );
                    this.groupCounter = maxGroupCounter;
                }
                
                this.updateDisplay();
                this.updatePropertiesSidebar();
                this.updateStatus('flowchart loaded successfully');
            } else {
                this.updateStatus('error loading flowchart');
            }
        } catch (error) {
            console.error('error loading flowchart:', error);
            this.updateStatus('error loading flowchart');
        }
    }

    async buildAction() {
        try {
            const response = await fetch('/api/build', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            if (response.ok) {
                const result = await response.json();
                this.updateStatus(`build: ${result.message}`);
            } else {
                this.updateStatus('build failed');
            }
        } catch (error) {
            console.error('build error:', error);
            this.updateStatus('build error');
        }
    }

    async runAction() {
        try {
            const response = await fetch('/api/run', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            if (response.ok) {
                const result = await response.json();
                this.updateStatus(`run: ${result.message}`);
            } else {
                this.updateStatus('run failed');
            }
        } catch (error) {
            console.error('run error:', error);
            this.updateStatus('run error');
        }
    }
}

// initialize the flowchart builder when the page loads
document.addEventListener('DOMContentLoaded', () => {
    new FlowchartBuilder();
});